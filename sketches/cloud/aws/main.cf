body file control
{
  namespace => "cfdc_cloud_aws";
}

bundle agent EC2(runenv, metadata, count, ami, region, type, class, install_cfengine, hub, options)
{
  classes:
      "$(vars)" expression => "default:runenv_$(runenv)_$(vars)";

      "start"   expression => strcmp("start", "$(state)");
      "stop"    expression => strcmp("stop",  "$(state)");

      "home_extracted" expression => regextract("(.+)/[^/]+",
                                                $(this.promise_filename),
                                                "home");

      "count_determined" expression => isvariable("current_count");

    count_determined::
      "change_not_needed" expression => strcmp($(count), $(current_count));
      "bootstrap_needed" expression => isgreaterthan($(count), $(current_count));
      "decom_needed" expression => islessthan($(count), $(current_count));

  vars:
      "vars" slist => { "@(default:$(runenv).env_vars)" };
      "$(vars)" string => "$(default:$(runenv).$(vars))";

    home_extracted::
      "bundle_home" string => "$(home[1])";

      # adjust for your Perl install, but any Perl should be able to handle this
      "perl"  string => "/usr/bin/perl";

      "shim" string => "$(perl) $(bundle_home)/scripts/shim.pl --netrc $($(options)[netrc]) --ec2 ami=$(ami) --ec2 instance_type=$(type) --ec2 region=$(region) --ec2 security_group=$($(options)[security_group]) --ec2 ssh_pub_key=$($(options)[ssh_pub_key]) --hub=$(hub) --install_cfengine=$(install_cfengine) ec2";

    home_extracted.test::
      "current_count" string => execresult("$(shim) count $(class)", "useshell");
    home_extracted.!test::
      "current_count" string => execresult("$(shim) count $(class) 2>/dev/null", "useshell");

  methods:
    verbose::
      "metadata" usebundle => default:report_metadata($(this.bundle), $(metadata)),
      inherit => "true";

  commands:
    count_determined.!change_not_needed::
      "$(shim) control $(count) $(class)";

  reports:
    count_determined::
      "$(this.bundle): EC2 current: $(current_count) $(class)";
    count_determined.verbose::
      "$(this.bundle): To run a command, e.g. ssh to all machine (but beware, this works best if you have just a few count): $(shim) ssh machine-name";
      "$(this.bundle): To see the console output of all the machines: $(shim) console machine-name";
      "$(this.bundle): To list all the machines: $(shim) list $(class)";
    count_determined.start.change_not_needed::
      "$(this.bundle): Service does not need to be started by the shim: $(count) instances of class $(class) already exist";
    count_determined.stop.change_not_needed::
      "$(this.bundle): Service does not need to be stopped by the shim: we have $(count) instances of class $(class)";
    count_determined.start.!change_not_needed::
      "$(this.bundle): Service will be started by the shim: $(count) instances of class $(class) (current $(current_count))";
    count_determined.stop.!change_not_needed::
      "$(this.bundle): Service will be stopped by the shim: $(count) instances (current $(current_count)) of class $(class) ";
    bootstrap_needed::
      "$(this.bundle): Bootstrapping will be needed";
    decom_needed::
      "$(this.bundle): Decom will be needed";
    cfengine::
      "$(this.bundle): EC2 goal: $(count) $(class).";

    verbose::
      "$(this.bundle): imported environment '$(runenv)' var '$(vars)' with value '$($(vars))'";
      "$(this.bundle): imported environment '$(runenv)' class '$(vars)' because 'default:runenv_$(runenv)_$(vars)' was defined"
      ifvarclass => "$(vars)";

    verbose.home_extracted::
      "$(this.bundle): bundle home is $(bundle_home)";
      "$(this.bundle): shim is $(shim)";
}

bundle agent S3_sync(directory, bucket, options)
{
  vars:
      "vars" slist => { "@(default:$(runenv).env_vars)" };
      "$(vars)" string => "$(default:$(runenv).$(vars))";
  classes:
      "$(vars)" expression => "default:runenv_$(runenv)_$(vars)";
  methods:
    verbose::
      "metadata" usebundle => default:report_metadata($(this.bundle), $(metadata)),
      inherit => "true";
  reports:
    verbose::
      "$(this.bundle): imported environment '$(runenv)' var '$(vars)' with value '$($(vars))'";
      "$(this.bundle): imported environment '$(runenv)' class '$(vars)' because 'default:runenv_$(runenv)_$(vars)' was defined"
      ifvarclass => "$(vars)";
}

bundle agent S3_clear(bucket, options)
{
  vars:
      "vars" slist => { "@(default:$(runenv).env_vars)" };
      "$(vars)" string => "$(default:$(runenv).$(vars))";
  classes:
      "$(vars)" expression => "default:runenv_$(runenv)_$(vars)";
  methods:
    verbose::
      "metadata" usebundle => default:report_metadata($(this.bundle), $(metadata)),
      inherit => "true";
  reports:
    verbose::
      "$(this.bundle): imported environment '$(runenv)' var '$(vars)' with value '$($(vars))'";
      "$(this.bundle): imported environment '$(runenv)' class '$(vars)' because 'default:runenv_$(runenv)_$(vars)' was defined"
      ifvarclass => "$(vars)";
}

bundle agent SDB_sync(directory, bucket, options)
{
  vars:
      "vars" slist => { "@(default:$(runenv).env_vars)" };
      "$(vars)" string => "$(default:$(runenv).$(vars))";
  classes:
      "$(vars)" expression => "default:runenv_$(runenv)_$(vars)";
  methods:
    verbose::
      "metadata" usebundle => default:report_metadata($(this.bundle), $(metadata)),
      inherit => "true";
  reports:
    verbose::
      "$(this.bundle): imported environment '$(runenv)' var '$(vars)' with value '$($(vars))'";
      "$(this.bundle): imported environment '$(runenv)' class '$(vars)' because 'default:runenv_$(runenv)_$(vars)' was defined"
      ifvarclass => "$(vars)";
}

bundle agent SDB_clear(bucket, options)
{
  vars:
      "vars" slist => { "@(default:$(runenv).env_vars)" };
      "$(vars)" string => "$(default:$(runenv).$(vars))";
  classes:
      "$(vars)" expression => "default:runenv_$(runenv)_$(vars)";
  methods:
    verbose::
      "metadata" usebundle => default:report_metadata($(this.bundle), $(metadata)),
      inherit => "true";
  reports:
    verbose::
      "$(this.bundle): imported environment '$(runenv)' var '$(vars)' with value '$($(vars))'";
      "$(this.bundle): imported environment '$(runenv)' class '$(vars)' because 'default:runenv_$(runenv)_$(vars)' was defined"
      ifvarclass => "$(vars)";
}

# # count = local directory, class = S3 bucket

# # sorry about the semantic mismatch, I wanted to keep things inside
# # Cloud::Services

# bundle agent s3(prefix, bundle_home, install_cfengine, count, class, state, params, hub)
# {
#   classes:
#       "start"   expression => strcmp("start",  "$(state)");
#       "stop"    expression => strcmp("stop",   "$(state)");

#   vars:
#       # adjust for your Perl install, but any Perl should be able to handle this
#       "perl"  string => "/usr/bin/perl";

#       "shim" string => "$(perl) $(bundle_home)/scripts/shim.pl  --s3 aws_access_key=$($(params)[aws_access_key]) --s3 aws_secret_key=$($(params)[aws_secret_key]) --s3 acl=$($(params)[acl]) s3";

#   commands:
#     start::
#       "$(shim) sync $(count) $(class)";
#     stop::
#       "$(shim) clear $(class)";

#   reports:
#     start::
#       "S3 goal: synchronize directory $(count) into S3 bucket $(class).";
#     stop::
#       "S3 goal: clear S3 bucket $(class).";
# }

# # count = file with JSON lines, class = SDB domain

# # sorry about the semantic mismatch, I wanted to keep things inside
# # Cloud::Services

# bundle agent sdb(prefix, bundle_home, install_cfengine, count, class, state, params, hub)
# {
#   classes:
#       "start"   expression => strcmp("start",  "$(state)");
#       "stop"    expression => strcmp("stop",   "$(state)");

#   vars:
#       # adjust for your Perl install, but any Perl should be able to handle this
#       "perl"  string => "/usr/bin/perl";

#       "shim" string => "$(perl) $(bundle_home)/scripts/shim.pl  --sdb aws_access_key=$($(params)[aws_access_key]) --sdb aws_secret_key=$($(params)[aws_secret_key]) sdb";

#   commands:
#     start::
#       "$(shim) sync $(count) $(class)";
#     stop::
#       "$(shim) clear $(class)";

#   reports:
#     start::
#       "SDB goal: synchronize JSON file $(count) into SDB domain $(class).";
#     stop::
#       "SDB goal: clear SDB domain $(class).";
# }

# bundle agent openstack(prefix, bundle_home, install_cfengine, count, class, state, params, hub)
# {
#   classes:
#       "start"   expression => strcmp("start",  "$(state)");
#       "stop"    expression => strcmp("stop",   "$(state)");

#       "count_determined" expression => isvariable("current_count");

#     count_determined::
#       "change_not_needed" expression => strcmp("$(count)", "$(current_count)");
#       "bootstrap_needed" expression => isgreaterthan("$(count)", "$(current_count)");
#       "decom_needed" expression => islessthan("$(count)", "$(current_count)");

#   vars:
#       # adjust for your Perl install, but any Perl should be able to handle this
#       "perl"  string => "/usr/bin/perl";

#       "shim" string => "$(perl) $(bundle_home)/scripts/shim.pl --openstack entry_url=$($(params)[entry_url]) --openstack password=$($(params)[password]) --openstack user=$($(params)[user]) --openstack key=$($(params)[key]) --openstack image=$($(params)[image]) --openstack master=$($(params)[master]) --hub=$(hub) --install_cfengine=$(install_cfengine) openstack";

#       "current_count" string => execresult("$(shim) count $(class) 2>/dev/null", "useshell");

#   commands:
#     count_determined.!change_not_needed::
#       "$(shim) control $(count) $(class)";

#   reports:
#     count_determined::
#       "Current count of $(class) = $(current_count)";
#     count_determined.cloud_services_verbose::
#       "To run a command, e.g. ssh to all machine (but beware, this works best if you have just a few count): $(shim) run $(class) 'ssh -i YOUR-PRIVATE-SSH-KEY -l ubuntu'";
#       "To see the console output of all the machines: $(shim) console $(class)";
#       "To list all the machines (just node names or all info, including DNS): $(shim) [list|list-full] $(class)";
#     count_determined.start.change_not_needed::
#       "Service does not need to be started by the shim: $(count) instances of class $(class) already exist";
#     count_determined.stop.change_not_needed::
#       "Service does not need to be stopped by the shim: we have $(count) instances of class $(class)";
#     count_determined.start.!change_not_needed::
#       "Service will be started by the shim: $(count) instances of class $(class) (current $(current_count))";
#     count_determined.stop.!change_not_needed::
#       "Service will be stopped by the shim: $(count) instances (current $(current_count)) of class $(class) ";
#     bootstrap_needed::
#       "Bootstrapping will be needed";
#     decom_needed::
#       "Decom will be needed";
#     cfengine::
#       "OpenStack goal: put $(count) $(class) in state $(state).";
# }
