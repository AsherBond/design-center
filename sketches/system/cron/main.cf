body file control
{
  namespace => "cfdc_cron";
}

bundle agent d(runenv, metadata, cron_path, file_task, runas, when, commands)
{
  classes:
      "$(vars)" expression => "default:runenv_$(runenv)_$(vars)";

  vars:
      "vars" slist => { "@(default:$(runenv).env_vars)" };
      "$(vars)" string => "$(default:$(runenv).$(vars))";

      "lines" slist  => maplist("#managed by cfengine cron sketch$(const.endl)$(when) $(runas) $(this)", "commands");

    !test::
      "r_cron_path" string => $(cron_path), policy => "free";
    test::
      "r_cron_path" string => "/tmp", policy => "free";

    any::
      "toedit" string => "$(r_cron_path)/cron-sketch-$(file_task)",
      policy => "free";

      "class_toedit" string => canonify($(toedit)),
      policy => "free";

  methods:
    verbose::
      "metadata" usebundle => default:report_metadata($(this.bundle), $(metadata)),
      inherit => "true";

  files:
      "$(toedit)"
      edit_line => default:append_if_no_lines("$(lines)"),
      edit_defaults => default:empty,
      create => "true",
      classes => default:if_ok($(class_toedit));

  reports:
    test::
      "$(this.bundle): running in test mode";
    verbose::
      "$(this.bundle): running in verbose mode";

    verbose::
      "$(this.bundle): imported environment '$(runenv)' var '$(vars)' with value '$($(vars))'";
      "$(this.bundle): imported environment '$(runenv)' class '$(vars)' because 'default:runenv_$(runenv)_$(vars)' was defined"
      ifvarclass => "$(vars)";

      "$(this.bundle): Activating '$(toedit)': run as $(runas) at times '$(when)', command '$(commands)'";
      "lines to be inserted in '$(toedit)' = $(lines)";

    any::
      "$(file_task)" bundle_return_value_index => "tab";
      "$(r_cron_path)" bundle_return_value_index => "path";
}

bundle agent tab(runenv, metadata, cron_path, line_task, runas, when, commands)
{
  classes:
      "$(vars)" expression => "default:runenv_$(runenv)_$(vars)";

  vars:
      "vars" slist => { "@(default:$(runenv).env_vars)" };
      "$(vars)" string => "$(default:$(runenv).$(vars))";

    !test::
      "r_cron_path" string => $(cron_path), policy => "free";
    test::
      "r_cron_path" string => "/bin/cat", policy => "free";

  methods:
    verbose::
      "metadata" usebundle => default:report_metadata($(this.bundle), $(metadata)),
      inherit => "true";

  reports:
    verbose::
      "$(this.bundle): imported environment '$(runenv)' var '$(vars)' with value '$($(vars))'";
      "$(this.bundle): imported environment '$(runenv)' class '$(vars)' because 'default:runenv_$(runenv)_$(vars)' was defined"
      ifvarclass => "$(vars)";

    any::
      "$(line_task)" bundle_return_value_index => "tab";
      "$(r_cron_path)" bundle_return_value_index => "path";
}

# bundle agent tab(class_prefix, cron_path, tasks, task)
# {
#   classes:
#       "only_allow_defined_entries" or => { "!$(class_prefix)nowipe" };

#   vars:
#     any::
#       "tprefix"   string => "$(tasks)[$(task)]";
#       "runas"     string => "$($(tprefix)[runas])";
#       "when"      string => "$($(tprefix)[when])";
#       "commands"  slist  => { "@($(tprefix)[commands])" };

#       "marker"    string => "MANAGED_BY_CFENGINE_CRON_SKETCH";
#       "lines"     slist  => maplist("$(when) $(marker)=1 $(this)", "commands");

#   files:
#     only_allow_defined_entries::
#       "/tmp/$(class_prefix)$(task).cron"
#       edit_line      => default:append_if_no_lines("$(tab.lines[$(task)])"),
#       edit_defaults  => default:empty,
#       create         => "true",
#       classes        => if_ok_define_and_cancel("$(class_prefix)$(task)_if_lines_added", only_allow_defined_entries),
#       ifvarclass     => "$(class_prefix)$(task)_prepared";

#     !only_allow_defined_entries::
#       "/tmp/$(class_prefix)$(task).cron"
#       edit_line      => default:append_if_no_lines("$(tab.lines[$(task)])"),
#       edit_defaults  => default:std_defs,
#       create         => "true",
#       classes        => default:if_ok("$(class_prefix)$(task)_if_lines_added"),
#       ifvarclass     => "$(class_prefix)$(task)_prepared";

#     any::
#       "/tmp/$(class_prefix)$(task).cron"
#       delete         => default:tidy,
#       ifvarclass     => "$(class_prefix)$(task)_if_crontab_changed|($(class_prefix)$(task)_prepared.!$(class_prefix)$(task)_if_lines_added)";

#   commands:
#       "$(cron_path) -u $(runas) -l > /tmp/$(class_prefix)$(task).cron",
#       contain        => default:in_shell,
#       classes        => default:if_ok("$(class_prefix)$(task)_prepared");

#       "$(cron_path) -u $(runas) /tmp/$(class_prefix)$(task).cron",
#       contain        => default:in_shell,
#       classes        => default:if_ok("$(class_prefix)$(task)_if_crontab_changed"),
#       ifvarclass     => "$(class_prefix)$(task)_if_lines_added";

#   reports:
#     default:debug::
#       "crontab manage: Activating '$(cron_path) $(class_prefix)$(task)' for task $(task) run as $(runas) at times '$(when)', command '$(commands)' @@ $(lines) @@ ";
#       "task prefix = $(tprefix)";
#       "lines to be inserted in '$(cron_path) $(class_prefix)$(task)' = $(lines)";
#     only_allow_defined_entries.default:debug::
#       "@@ Crontab may be emptied ! @@";
# }

# body classes if_ok_define_and_cancel(dcl,cl)
# {
#     promise_repaired => { "$(dcl)" };
#     promise_kept => { "$(dcl)" };
#     cancel_repaired => { "$(cl)" };
#     cancel_kept => { "$(cl)" };
# }
