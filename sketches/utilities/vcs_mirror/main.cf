body file control
{
      namespace => "cfdc_vcs";
}

bundle agent mirror(runenv, metadata, vcs, path, origin, branch, options)
{
  methods:
    known_vcs::
      "setup" usebundle => $(vcs_type)($(vcs),
                                       $(path),
                                       $(origin),
                                       $(branch),
                                       $(options)),
      inherit => "true";

    parent_parsed::
      "ensure" usebundle => ensure_parent("$(parent_capture[1])",
                                          "$(options)[parent_dir]"),
      inherit => "true";

  vars:
      "vars" slist => { "@(default:$(runenv).env_vars)" };
      "$(vars)" string => "$(default:$(runenv).$(vars))";

    any::
      "vcs_type" string => lastnode("$(vcs)","/");
      "runas" string => "$($(options)[vcs][runas])";
      "umask" string => "$($(options)[vcs][umask])";

    any::
      # pretty-print the authors and dependencies
      "dependencies" string => join(", ", "$(metadata)[depends]");
      "authors" string => join(", ", "$(metadata)[authors]");

  classes:
      "$(vars)" expression => "default:runenv_$(runenv)_$(vars)";

      "use_git" expression => strcmp($(vcs_type), "git");
      "use_svn" expression => strcmp($(vcs_type), "svn");
      "known_vcs" or => { "use_git", "use_svn" };
      "unknown_vcs" expression => "!known_vcs";

      "variables_ok" and => { "known_vcs" };
      "vcs_has_config_template" expression => "$(vcs_type)_has_config_template";

      "path_exists" expression => fileexists("$(path)");

      "parent_parsed" expression => regextract("(.+)/[^/]+$",
                                               $(path),
                                               "parent_capture");

    #   "second_pass" expression => "any";
    #   "third_pass" expression => "second_pass";

    known_vcs::
      "vcsconfig_exists" expression => fileexists("$(cfdc_vcs:$(vcs_type).configfile)");
      "no_vcsconfig_exists" expression => "!vcsconfig_exists";

  files:
    # variables_ok.use_git::
    #   "$(git_configfile)"
    #   handle => "$(vcs_type)_configfile_contents",
    #   comment => "Expand Git config file from variable",
    #   create => "false",
    #   edit_defaults => default:empty,
    #   edit_line => default:insert_lines("$(git_config_template)");

  commands:

    # variables_ok.vcsconfig_exists::
    #   "$($(vcs_type)_update_command)"
    #   handle     => "$(vcs_type)_update_with_user_command",
    #   contain    => test_aware_contain("$(runas)", "$(path)", "$(umask)"),
    #   ifvarclass => "!vcs_mirrored",
    #   classes    => bundle_if_ok("vcs_updated"),
    #   comment    => "Update an existing VCS repository in $(path), user override to $(runas)";

    # variables_ok.!vcsconfig_exists::
    #   "$($(vcs_type)_mirror_command)"
    #   handle     => "$(vcs_type)_mirror_with_user_command",
    #   contain    => test_aware_contain("$(runas)", "/", "$(umask)"),
    #   ifvarclass => "!vcs_mirrored",
    #   classes    => bundle_if_ok("vcs_mirrored"),
    #   comment    => "Clone a VCS repository in $(path), user override to $(runas)";

  reports:
    verbose::
      "$(this.bundle): imported environment '$(runenv)' var '$(vars)' with value '$($(vars))'";
      "$(this.bundle): imported environment '$(runenv)' class '$(vars)' because 'default:runenv_$(runenv)_$(vars)' was defined"
      ifvarclass => "$(vars)";

    verbose::
      "$(this.bundle): $($(metadata)[name]) license = $($(metadata)[license])";
      "$(this.bundle): $($(metadata)[name]) dependencies = $(dependencies)";

      "$(this.bundle): $($(metadata)[name]) version $($(metadata)[version]) by $(authors) starting up...";
    verbose::
      "$(this.bundle): running in verbose mode";
    test::
      "$(this.bundle): running in test mode";

    unknown_vcs::
      "$(this.bundle): sorry, the requested VCS '$(vcs)' is not handled yet.";

    verbose.variables_ok::
      "$(this.bundle): VCS is $(vcs), to be executed as user $(runas) / umask $(umask)";
    verbose.variables_ok.vcs_has_config_template::
      "$(this.bundle): VCS $(vcs) has a config template";
    veryverbose.variables_ok.vcs_has_config_template::
      "$(this.bundle): VCS $(vcs) config template = $(cfdc_vcs:$(vcs_type).config_template)";
    verbose.variables_ok.!vcs_has_config_template::
      "$(this.bundle): VCS $(vcs) has no config template";

    verbose.variables_ok.vcsconfig_exists::
      "$(this.bundle): VCS config file $(cfdc_vcs:$(vcs_type).configfile) exists";

    verbose.variables_ok.no_vcsconfig_exists::
      "$(this.bundle): VCS config file $(cfdc_vcs:$(vcs_type).configfile) does not exist";

    verbose.vcs_mirrored::
      "$(this.bundle): New clone of $(origin) (branch $(branch) created in $(path)";

    variables_ok.path_exists.no_vcsconfig_exists::
      "$(this.bundle): Sorry, we could not clone $(origin) (branch $(branch)) in $(path) because that path already exists";

      # return the deployed path when successful
    vcs_mirrored||vcs_updated::
      "$(path)" bundle_return_value_index => "deploy_path";
}

bundle agent git(vcs, path, origin, branch, options)
{
  classes:
      "nowipe" expression => strcmp("$($(options)[nowipe])", "1");
      "wipe" expression => "!nowipe";

  vars:
    wipe::
      "update_command" slist =>
      {
        # Fetch repo contents
        "$(vcs) fetch -t origin +refs/heads/*:refs/remotes/origin/*",
        # Remove untracked files
        "$(vcs) clean -f -f -x -q -d .",
        # Discard changes to index and working tree since HEAD
        "$(vcs) reset -q --hard HEAD",
        # Check out the proper branch
        "$(vcs) checkout -q $(branch)",
        # Pull the latest changes from origin
        "$(vcs) pull -q -s recursive -Xtheirs origin $(branch)",
        # Reset the working tree to the latest updates
        "$(vcs) reset -q --hard HEAD",
      };

    nowipe::
      "update_command" slist =>
      {
        "$(vcs) pull origin $(branch)",
      };

    any::

      "mirror_command" slist =>
      {
        # clone the given repository with Git
        "$(vcs) clone -b $(branch) $(origin) $(path)"
      };

      "configfile" string => "$(path)/.git/config";

      "config_template" string => "
[core]
repositoryformatversion = 0
filemode = true
bare = false
logallrefupdates = true
[remote \"origin\"]
fetch = +refs/heads/*:refs/remotes/origin/*
url = $(origin)
[branch \"master\"]
remote = origin
merge = refs/heads/master
[branch \"$(branch)\"]
remote = origin
merge = refs/heads/$(branch)
",
      comment => "The configfile template.",
      handle => "update_vars_git_config_template",
      classes => default:always("git_has_config_template");

  reports:
    verbose::
      "$(this.bundle): setting up $(vcs) commands for path '$(path)', origin '$(origin)', branch '$(branch)'";
      "$(this.bundle): we will look for the config file $(configfile)";
      "$(this.bundle): update_command = $(update_command)";
      "$(this.bundle): mirror_command = $(mirror_command)";
}

bundle agent svn(vcs, path, origin, branch, options)
{
  classes:
      "nowipe" expression => strcmp("$($(options)[nowipe])", "1");
      "wipe" expression => "!nowipe";

  vars:
    nowipe::
      "update_command" slist =>
      {
        "$(vcs) cleanup",
        "$(vcs) up",
      };

    wipe::
      "update_command" slist =>
      {
        "$(vcs) cleanup",
        "$(vcs) up",
        "$(vcs) revert",
      };

    any::
      "mirror_command" slist =>
      {
        # clone the given repository with Subversion
        "$(vcs) co $(origin) $(path)"
      };

      "configfile" string => "$(path)/.svn/entries";

      # no config template
      "config_template" string => "";

  reports:
    verbose::
      "$(this.bundle): setting up $(vcs) commands for path '$(path)', origin '$(origin)', branch '$(branch)'";
      "$(this.bundle): we will look for the config file $(configfile)";
      "$(this.bundle): update_command = $(update_command)";
      "$(this.bundle): mirror_command = $(mirror_command)";
}

bundle agent ensure_parent(parent_path, options)
{
  classes:
      "ensure" expression => strcmp("$($(options)[ensure])", "1");

  files:
    ensure.parent_parsed::
      "$(parent_path)/."
      create => "true",
      perms => default:mog("$($(options)[perms])",
                           "$($(options)[owner])",
                           "$($(options)[group])");

  reports:
    verbose.!ensure::
      "$(this.bundle): will not ensure parent path = '$(parent_path)'";
    verbose.ensure::
      "$(this.bundle): will ensure parent path '$(parent_path)' with mog parameters '$($(options)[perms])', '$($(options)[owner])', '$($(options)[group])'";
}

body contain test_aware_contain(user, dir, umask)
{
      chdir => "$(dir)";
      umask => "$(umask)";
    !test::
      exec_owner => "$(user)";
    test::
      exec_owner => getenv("LOGNAME", 100);
}

body classes bundle_if_ok(x)
{
      scope => "bundle";
      promise_repaired => { "$(x)" };
      promise_kept => { "$(x)" };
}
